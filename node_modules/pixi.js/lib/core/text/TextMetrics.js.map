{"version":3,"sources":["../../../src/core/text/TextMetrics.js"],"names":["TextMetrics","text","style","width","height","lines","lineWidths","lineHeight","maxLineWidth","fontProperties","measureText","wordWrap","canvas","_canvas","font","toFontString","measureFont","context","getContext","outputText","split","Array","length","i","lineWidth","letterSpacing","Math","max","strokeThickness","dropShadow","dropShadowDistance","fontSize","leading","result","firstChar","charAt","wordWrapWidth","characterCache","spaceLeft","words","j","wordWidth","breakWords","characters","c","character","characterWidth","undefined","wordWidthWithSpace","_fonts","properties","_context","ceil","baseline","fillStyle","fillRect","textBaseline","fillText","imagedata","getImageData","data","pixels","line","idx","stop","ascent","descent","document","createElement"],"mappings":"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","file":"TextMetrics.js","sourcesContent":["/**\n * The TextMetrics object represents the measurement of a block of text with a specified style.\n *\n * @class\n * @memberOf PIXI\n */\nexport default class TextMetrics\n{\n    /**\n     * @param {string} text - the text that was measured\n     * @param {PIXI.TextStyle} style - the style that was measured\n     * @param {number} width - the measured width of the text\n     * @param {number} height - the measured height of the text\n     * @param {array} lines - an array of the lines of text broken by new lines and wrapping if specified in style\n     * @param {array} lineWidths - an array of the line widths for each line matched to `lines`\n     * @param {number} lineHeight - the measured line height for this style\n     * @param {number} maxLineWidth - the maximum line width for all measured lines\n     * @param {Object} fontProperties - the font properties object from TextMetrics.measureFont\n     */\n    constructor(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties)\n    {\n        this.text = text;\n        this.style = style;\n        this.width = width;\n        this.height = height;\n        this.lines = lines;\n        this.lineWidths = lineWidths;\n        this.lineHeight = lineHeight;\n        this.maxLineWidth = maxLineWidth;\n        this.fontProperties = fontProperties;\n    }\n\n    /**\n     * Measures the supplied string of text and returns a Rectangle.\n     *\n     * @param {string} text - the text to measure.\n     * @param {PIXI.TextStyle} style - the text style to use for measuring\n     * @param {boolean} [wordWrap] - optional override for if word-wrap should be applied to the text.\n     * @param {HTMLCanvasElement} [canvas] - optional specification of the canvas to use for measuring.\n     * @return {PIXI.TextMetrics} measured width and height of the text.\n     */\n    static measureText(text, style, wordWrap, canvas = TextMetrics._canvas)\n    {\n        wordWrap = wordWrap || style.wordWrap;\n        const font = style.toFontString();\n        const fontProperties = TextMetrics.measureFont(font);\n        const context = canvas.getContext('2d');\n\n        context.font = font;\n\n        const outputText = wordWrap ? TextMetrics.wordWrap(text, style, canvas) : text;\n        const lines = outputText.split(/(?:\\r\\n|\\r|\\n)/);\n        const lineWidths = new Array(lines.length);\n        let maxLineWidth = 0;\n\n        for (let i = 0; i < lines.length; i++)\n        {\n            const lineWidth = context.measureText(lines[i]).width + ((lines[i].length - 1) * style.letterSpacing);\n\n            lineWidths[i] = lineWidth;\n            maxLineWidth = Math.max(maxLineWidth, lineWidth);\n        }\n        let width = maxLineWidth + style.strokeThickness;\n\n        if (style.dropShadow)\n        {\n            width += style.dropShadowDistance;\n        }\n\n        const lineHeight = style.lineHeight || fontProperties.fontSize + style.strokeThickness;\n        let height = Math.max(lineHeight, fontProperties.fontSize + style.strokeThickness)\n            + ((lines.length - 1) * (lineHeight + style.leading));\n\n        if (style.dropShadow)\n        {\n            height += style.dropShadowDistance;\n        }\n\n        return new TextMetrics(\n            text,\n            style,\n            width,\n            height,\n            lines,\n            lineWidths,\n            lineHeight + style.leading,\n            maxLineWidth,\n            fontProperties\n        );\n    }\n\n    /**\n     * Applies newlines to a string to have it optimally fit into the horizontal\n     * bounds set by the Text object's wordWrapWidth property.\n     *\n     * @private\n     * @param {string} text - String to apply word wrapping to\n     * @param {PIXI.TextStyle} style - the style to use when wrapping\n     * @param {HTMLCanvasElement} [canvas] - optional specification of the canvas to use for measuring.\n     * @return {string} New string with new lines applied where required\n     */\n    static wordWrap(text, style, canvas = TextMetrics._canvas)\n    {\n        const context = canvas.getContext('2d');\n\n        // Greedy wrapping algorithm that will wrap words as the line grows longer\n        // than its horizontal bounds.\n        let result = '';\n        const firstChar = text.charAt(0);\n        const lines = text.split('\\n');\n        const wordWrapWidth = style.wordWrapWidth;\n        const characterCache = {};\n\n        for (let i = 0; i < lines.length; i++)\n        {\n            let spaceLeft = wordWrapWidth;\n            const words = lines[i].split(' ');\n\n            for (let j = 0; j < words.length; j++)\n            {\n                const wordWidth = context.measureText(words[j]).width;\n\n                if (style.breakWords && wordWidth > wordWrapWidth)\n                {\n                    // Word should be split in the middle\n                    const characters = words[j].split('');\n\n                    for (let c = 0; c < characters.length; c++)\n                    {\n                        const character = characters[c];\n                        let characterWidth = characterCache[character];\n\n                        if (characterWidth === undefined)\n                        {\n                            characterWidth = context.measureText(character).width;\n                            characterCache[character] = characterWidth;\n                        }\n\n                        if (characterWidth > spaceLeft)\n                        {\n                            result += `\\n${character}`;\n                            spaceLeft = wordWrapWidth - characterWidth;\n                        }\n                        else\n                        {\n                            if (c === 0 && (j > 0 || firstChar === ' '))\n                            {\n                                result += ' ';\n                            }\n\n                            result += character;\n                            spaceLeft -= characterWidth;\n                        }\n                    }\n                }\n                else\n                {\n                    const wordWidthWithSpace = wordWidth + context.measureText(' ').width;\n\n                    if (j === 0 || wordWidthWithSpace > spaceLeft)\n                    {\n                        // Skip printing the newline if it's the first word of the line that is\n                        // greater than the word wrap width.\n                        if (j > 0)\n                        {\n                            result += '\\n';\n                        }\n                        result += words[j];\n                        spaceLeft = wordWrapWidth - wordWidth;\n                    }\n                    else\n                    {\n                        spaceLeft -= wordWidthWithSpace;\n                        result += ` ${words[j]}`;\n                    }\n                }\n            }\n\n            if (i < lines.length - 1)\n            {\n                result += '\\n';\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Calculates the ascent, descent and fontSize of a given font-style\n     *\n     * @static\n     * @param {string} font - String representing the style of the font\n     * @return {PIXI.TextMetrics~FontMetrics} Font properties object\n     */\n    static measureFont(font)\n    {\n        // as this method is used for preparing assets, don't recalculate things if we don't need to\n        if (TextMetrics._fonts[font])\n        {\n            return TextMetrics._fonts[font];\n        }\n\n        const properties = {};\n\n        const canvas = TextMetrics._canvas;\n        const context = TextMetrics._context;\n\n        context.font = font;\n\n        const width = Math.ceil(context.measureText('|MÉq').width);\n        let baseline = Math.ceil(context.measureText('M').width);\n        const height = 2 * baseline;\n\n        baseline = baseline * 1.4 | 0;\n\n        canvas.width = width;\n        canvas.height = height;\n\n        context.fillStyle = '#f00';\n        context.fillRect(0, 0, width, height);\n\n        context.font = font;\n\n        context.textBaseline = 'alphabetic';\n        context.fillStyle = '#000';\n        context.fillText('|MÉq', 0, baseline);\n\n        const imagedata = context.getImageData(0, 0, width, height).data;\n        const pixels = imagedata.length;\n        const line = width * 4;\n\n        let i = 0;\n        let idx = 0;\n        let stop = false;\n\n        // ascent. scan from top to bottom until we find a non red pixel\n        for (i = 0; i < baseline; ++i)\n        {\n            for (let j = 0; j < line; j += 4)\n            {\n                if (imagedata[idx + j] !== 255)\n                {\n                    stop = true;\n                    break;\n                }\n            }\n            if (!stop)\n            {\n                idx += line;\n            }\n            else\n            {\n                break;\n            }\n        }\n\n        properties.ascent = baseline - i;\n\n        idx = pixels - line;\n        stop = false;\n\n        // descent. scan from bottom to top until we find a non red pixel\n        for (i = height; i > baseline; --i)\n        {\n            for (let j = 0; j < line; j += 4)\n            {\n                if (imagedata[idx + j] !== 255)\n                {\n                    stop = true;\n                    break;\n                }\n            }\n\n            if (!stop)\n            {\n                idx -= line;\n            }\n            else\n            {\n                break;\n            }\n        }\n\n        properties.descent = i - baseline;\n        properties.fontSize = properties.ascent + properties.descent;\n\n        TextMetrics._fonts[font] = properties;\n\n        return properties;\n    }\n}\n\n/**\n * Internal return object for {@link PIXI.TextMetrics.measureFont `TextMetrics.measureFont`}.\n * @class FontMetrics\n * @memberof PIXI.TextMetrics~\n * @property {number} ascent - The ascent distance\n * @property {number} descent - The descent distance\n * @property {number} fontSize - Font size from ascent to descent\n */\n\nconst canvas = document.createElement('canvas');\n\ncanvas.width = canvas.height = 10;\n\n/**\n * Cached canvas element for measuring text\n * @memberof PIXI.TextMetrics\n * @type {HTMLCanvasElement}\n * @private\n */\nTextMetrics._canvas = canvas;\n\n/**\n * Cache for context to use.\n * @memberof PIXI.TextMetrics\n * @type {CanvasRenderingContext2D}\n * @private\n */\nTextMetrics._context = canvas.getContext('2d');\n\n/**\n * Cache of PIXI.TextMetrics~FontMetrics objects.\n * @memberof PIXI.TextMetrics\n * @type {Object}\n * @private\n */\nTextMetrics._fonts = {};\n"]}